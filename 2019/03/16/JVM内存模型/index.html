<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Li Jiangtao"><link rel="alternative" href="/atom.xml" title="zhulinyin" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>JVM内存模型 - zhulinyin</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">zhulinyin</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2019-03-16T11:32:25.000Z">March 16, 2019</time><h1 class="post__title"><a href="/2019/03/16/JVM内存模型/">JVM内存模型</a></h1><div class="post__main echo"><p>JVM的内存模型分为五个区域</p>
<h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令。为了使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，用以记录当前执行到的指令。</p>
<h3 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h3><p>Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，栈帧中存放了：</p>
<ol>
<li>局部变量表</li>
<li>操作数栈</li>
<li>指向运行时常量池的引用</li>
<li>方法返回地址</li>
<li>一些额外的附加信息。</li>
</ol>
<p>Java栈是线程私有的，当线程执行一个方法时，就会创建一个栈帧并压栈；当方法执行完毕之后，便会将栈帧出栈。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与Java栈的作用和原理非常相似，区别在于Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法服务的。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是用来存储对象和数组。堆是被所有线程共享的，在JVM中只有一个堆。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是被所有线程共享的，它存放了：</p>
<ol>
<li>每个类的信息（包括类的名称、方法信息、字段信息）</li>
<li>静态变量</li>
<li>运行时常量池（包括class文件中的常量池和运行时产生的常量）<ul>
<li>class文件中的常量池包含了字面量和符号引用。字面量相当于Java语言的常量，如文本字符串，声明为final的常量等。符号引用包括类和接口的全限定名、字段名称和描述符、方法名称和描述符。</li>
</ul>
</li>
<li>编译器编译后的代码</li>
</ol>
<h3 id="JMM-Java内存模型"><a href="#JMM-Java内存模型" class="headerlink" title="JMM(Java内存模型)"></a>JMM(Java内存模型)</h3><p>JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory），线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。主内存包括Java堆、方法区；线程的工作内存包括Java栈、本地方法栈、PC寄存器。</p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/Java/">Java</a></li></ul></footer></article></main><footer class="foot"><div class="foot-copy">&copy; 2018-2019 Li Jiangtao</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>